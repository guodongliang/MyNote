按某种规则去匹配符合规则的字符串

javascript中通过内置对象refexp支持正则表达式
实例化Regexp对象
1.字面量
var reg=/\bis\b/g
\b 单词边界     g：全局匹配
replce（a,b）将所有的a替换成B

构造函数
var reg=new Regexp("\\bis\\b",'g')  需要 \ 转义
var reg=/\bis\b/gi   i：默认是区分大小写的，i忽略大小写      m：多行搜索，把换行的一行当做新的一行，此时^可以发挥作用了


元字符
- 原义文本字符   a，1,2,3
- 元字符		
元字符是在正则表达式中有特殊含义的字符 
* + ? $ ^ . | \ () {} []

元字符
\t  	水平制表符    +tab键
\v	垂直制表符
\n	换行符
\r	回车符
\0	空字符
\f	换页符
\cX	Ctrl+X

[abc]   有一个就满足条件
[^abc]字符类取反   不是abc的都满足 


范围类
[a-z]  代表a到z的字母
[a-zA-Z]大小写都匹配
也可以在 [] 中使用-   [0-9-]这样可以匹配到-

预定义类
.  除了回车换行之外的所有字符
\d	数字字符		digit
\D	非数字字符
\s	空白符		space
\S	非空白符
\w	单词字符（字母，数字下划线）	word
\W	非单词字符

边界
^	开头
&	结尾
\b	单词边界
\B	非单词边界，不是单词的边界

量词
{20}  代表20次
{0,10}最多10次
{3，}至少3次
？最多出现一次
+ 最少出现一次
* 任意次（包含0次）

正则的贪婪模式 和 非贪婪模式
贪婪模式
\d{3,6}  尽可能多的匹配
非贪婪模式
\d{3,6} ？ 在量词后加？ 是非贪婪模式

分组
(digit){3}  匹配整个分组的字符，不是单一的字符
$1-$n 会捕获分组的内容
忽略分组
（？：asd）-（ok）  $1是ok

前瞻
正向前瞻
/\d(?=\d)/g  数字后的是数字则符合  
3是属于 \w？-----------------------------------------------
负向前瞻


对象属性
reg.global      默认是false，若对正则设置/\D/gim   此时为ture
reg.ingorecase
reg.multiline
source：正则表达式的文本字符串
/\D/.source       \D
lastIndex  当前匹配结果的最后一个字符的下一个字符的索引值，非全局下无效
对一个较长的字符进行匹配时，每次匹配后的lastIndex是不一样的

正则方法test 和 exec方法
var reg=/\w/;
var reg2=/\w/g;
reg.test('ab')   => ture
reg2.test('ab')  => 此时，若采用全局匹配，则第三次会出现false，由于每次匹配都是一直向后的，是基于上一个位置的

exec（）
var reg3=/\d\d/
var reg4=/\d\d/g

var a = reg3.exe('234c4xv5')
a.index  得到当前匹配的字符在原字符串的索引位置。和lastIndex一起构成 [    ),形成该结果的索引值区间
reg3.exe执行后的结果：
若正则表达式中有分组
则 [符合正则的满足值，分组1，分组2.。。。]  ，返回的是一个数组 分组代表的是此时匹配值得分组的值   【‘1a2’,"a"】

字符串对象方法
str.search(规则限制，具体的字符是会转为正则规则的，)
 str.search(/\D/）
str.match()   非全局调用,结果和exe类似
str.split(',')	将字符串变为数组
str.split（/\d/g）将字符串中的所有符合值 集合为数组
str.replace('1',2)
str.replace（reg，val）
str.replace（reg，function（匹配的字符串，分组内容可有多个，匹配项在字符串中的index，原字符串）{ 。。。}）




